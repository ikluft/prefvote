#!/usr/bin/perl
# PODNAME: run-tests
# test script launcher for PrefVote preference voting system

use Modern::Perl qw(2015); # require 5.20.0 or later
use autodie;
use Carp qw(croak);
use Config;
use English;
use Cwd;
use Readonly;
use Getopt::Long;
use Term::ANSIColor;
use IO::Interactive qw(is_interactive);
use IPC::Run qw(run);
use TAP::Parser qw/all/;
use TAP::Parser::Aggregator qw/all/;

# configuration settings per language implementation
Readonly::Array my @supported_languages => (qw(perl));
Readonly::Hash my %config => (
    blackbox => {
        data => "test/inputs",
        test_re => qr{\.(yaml|yml)$},
    },
    "perl" => {
        build => 'dzil build',
        whitebox => {
            dirs => [qw(src/perl/prefvote src/perl/stv)],
            #dirs => [qw(src/perl/prefvote src/perl/stv src/perl/schulze)],
            testdir => "t",
            test_re => qr{\.t$},
            tp_args => [switches => ['-I../prefvote/lib', '-Ilib']],
        },
        prove_params => "--lib",
        blackbox => {
            env => {
                PERL5LIB => '${cwd}/prefvote/lib:${cwd}/stc/lib:${env/PERL5LIB}',
            },
            cmd => [ 'src/perl/bin/vote-count', "--test"],
        }
    },
);

# save original working directory (before any chdirs)
Readonly::Scalar my $orig_cwd => getcwd();

# test result text coloring for Test::Harness
Readonly::Hash my %callbacks => (
    test => sub {
        my $test = shift;
        if ( $test->is_ok && not $test->directive ) {
            # normal passing test
            print color 'green';
        }
        elsif ( !$test->is_ok ) {    # even if it's TODO
            print color 'red';
        }
        elsif ( $test->has_skip ) {
            print color 'white on_blue';

        }
        elsif ( $test->has_todo ) {
            print color 'white';
        }
    },
    ELSE => sub {
        # plan, comment, and so on (anything which isn't a test line)
        print color 'bright_blue';
    },
    ALL => sub {
        # now print them
        print shift->as_string;
        print color 'reset';
        print "\n";
    },
);

# string substitution query (used by str_expand)
sub str_subst
{
    my $query = shift;
    my @query_parts = split '/', $query;

    # environment variable lookup
    if ($query_parts[0] eq 'env') {
        return $ENV{$query_parts[1]} // "";
    }

    # perl configuration lookup
    if ($query_parts[0] eq 'perl') {
        return Config($query_parts[1]);
    }

    # program configuration lookup
    if ($query_parts[0] eq 'prog') {
        shift @query_parts;
        my $configref = \%config;
        while (ref $configref eq "HASH") {
            my $key = shift @query_parts;
            if (not exists $configref->{$key}) {
                return "";
            }
            $configref = $configref->{$key};
        }
        return $configref;
    }


    # current working directory (as of program start)
    if ($query_parts[0] eq 'cwd') {
        return $orig_cwd;
    }

    # default to blank
    return "";
}

# simple string expansion utility
sub str_expand
{
    my $in_str = shift;
    my $out_str = "";
    my $pos = 0;

    # scan through string looking for escapes '\' or expansions '$'
    while ($pos < length $in_str) {
        my $slash = index($in_str, '\\', $pos);
        my $dollar = index($in_str, '$', $pos);

        # if next backslash occurs before dollar sign, process the escape
        if ($slash>=0 and ($dollar==-1 or $slash<$dollar)) {
            $out_str .= substr($in_str, $pos, $slash-$pos);
            $pos = $slash+1;
            if ($pos > length $in_str) {
                $out_str .= '\\';
                last;
            }
            $out_str .= substr($in_str, $pos-1, 1);
            next;
        }

        # check first occurrence of a dollar sign in the remainder of the string for a variable expansion
        if ($dollar>=0) {
            if (substr($in_str, $dollar) =~ m/^\$\{([^}]+)\}/x) {
                my $query = $1;
                my $subst = str_subst($query);
            }
        }
    }
}

# search directory for test files
sub find_test_files
{
    my ($dir, $test_re) = @_;

    # find test scripts in subdirectories
    say STDERR "find_test_file ($dir, $test_re)";
    opendir(my $dh, "$dir")
        or croak "Can't open $dir: $! (cwd=".getcwd().")";
    my @all = grep { $_ !~ /^\./ } readdir($dh);
    closedir $dh;
    my @files;
    foreach my $name (@all) {
        my $path = $dir."/".$name;
        if (-f $path and $path =~ $test_re) {
            push @files, $path;
        } elsif (-d $path) {
            push @files, find_test_files($path, $test_re);
        }
    }
    say STDERR "find_test_file $dir -> : ".join(" ", @files);

    return @files;
}

# run whitebox (unit) tests
sub run_whitebox_tests
{
    my %opts = @_;
    my $lang = $opts{lang};
    my $agg = $opts{agg};
    foreach my $dir (@{$config{$lang}{whitebox}{dirs}}) {
        ( -d "$dir" )
            or croak "configure whitebox testing directory $dir is not a directory";
        chdir $dir;
        my $testdir = $config{$lang}{whitebox}{testdir};
        my $test_re = $config{$lang}{whitebox}{test_re};
        if ( -d $testdir ) {
            # enter whitebox test directory and find test scripts
            my @files = find_test_files($testdir, $test_re);

            # run tests
            foreach my $file (@files) {
                (-f $file) or next;
                say "running whitebox tests: $dir/$file";
                my $parser = TAP::Parser->new({
                    source => $file,
                    @{$config{$lang}{whitebox}{tp_args}},
                    (is_interactive() ? (callbacks => \%callbacks) : ()),
                });
                while ( my $result = $parser->next ) {
                    if (not is_interactive()) {
                        say $result->as_string;
                    }
                }
                printf "Planned: %s\nPassed: %s\nFailed: %s\n\n",
                    $parser->tests_planned, scalar $parser->passed, scalar $parser->failed;
                    $agg->add($file, $parser);
            }
        } else {
            croak("test (t) directory not found in configured directory $dir");
        }
        chdir $orig_cwd;
    }
    return;
}

# run blackbox tests (applicable across languages, can't use knowledge of implementation)
sub run_blackbox_tests
{
    my %opts = @_;
    my $lang = $opts{lang};
    my $agg = $opts{agg};

    # collect blackbox test parameters for selected language
    if (not exists $config{$lang}{blackbox}) {
        croak "blackbox tests not configured for language $lang";
    }
    if (not exists $config{$lang}{blackbox}{cmd}) {
        croak "blackbox test command not configured for language $lang";
    }
    if (ref $config{$lang}{blackbox}{cmd} ne "ARRAY") {
        croak "blackbox test command improperly configured for language $lang - not an ARRAY ref";
    }
    my @blackbox_cmd = @{$config{$lang}{blackbox}{cmd}};
    my $blackbox_env = $config{$lang}{blackbox}{env} // {};
    # TODO add language-specific blackbox test build parameters here

    # enter blackbox test directory and find test data files
    my $testdir = $config{blackbox}{data};
    my $test_re = $config{blackbox}{test_re};
    my @test_files = find_test_files($testdir, $test_re);

    # run blackbox tests for the selected language on the test data
    foreach my $test_file (@test_files) {
        (-f $test_file) or next;
        say "running blackbox tests: $test_file";

        # run the blackbox tests in the selected language
        my $bbt_out;
        run \@blackbox_cmd, \undef, \$bbt_out,
            init => sub { foreach my $key (keys %$blackbox_env) {$ENV{$key} = $blackbox_env->{$key} } };

        # parse the TAP output
        my $parser = TAP::Parser->new({
            tap => \$bbt_out,
            @{$config{$lang}{whitebox}{tp_args}},
            (is_interactive() ? (callbacks => \%callbacks) : ()),
        });
        while ( my $result = $parser->next ) {
            if (not is_interactive()) {
                say $result->as_string;
            }
        }
        printf "Planned: %s\nPassed: %s\nFailed: %s\n\n",
            $parser->tests_planned, scalar $parser->passed, scalar $parser->failed;
            $agg->add($test_file, $parser);
    }
}

# process command-line
my (@language, $whitebox, $blackbox, $all);
GetOptions("language:s" => \@language, "whitebox|white|w" => \$whitebox, "blackbox|black|b" => \$blackbox,
    "all" => \$all);

#
# run tests as selected
#

# aggregator collects results from all tests
my $aggregate = TAP::Parser::Aggregator->new(
);

# process --all
if ($all) {
    $whitebox = 1;
    $blackbox = 1;
    @language = @supported_languages;
}

# whitebox and blackbox tests within each language implementation's sources
{
    local $ENV{PREFVOTE_ROOT} = $orig_cwd; # unit tests must look for this and run relative to the project root
    foreach my $lang (@language) {
        if ($whitebox) {
            run_whitebox_tests(lang => $lang, agg => $aggregate);
        }
        if ($blackbox) {
            run_blackbox_tests(lang => $lang, agg => $aggregate);
        }
    }
}

# print results
printf "Total: %s\nPlanned: %s\nPassed: %s\nFailed: %s\n",
$aggregate->total, scalar $aggregate->planned, scalar $aggregate->passed, scalar $aggregate->failed;
