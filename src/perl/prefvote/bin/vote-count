#!/usr/bin/perl
# PODNAME: vote-count
# command line interface to run PrefVote::STV processing YAML input for testing and simple usage example
# derived from Vote::STV by Ian Kluft
# Copyright (c) 1998-2021 by Ian Kluft
# Open Source license: Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0

use Modern::Perl qw(2015); # require 5.20.0 or later
use autodie;
use Carp qw(croak confess);;
use YAML::XS; # RPM: perl-YAML-LibYAML, DEB: libyaml-libyaml-perl
use PrefVote::Core;
use Getopt::Long;
use Scalar::Util 'reftype';
use Data::Dumper;

# print results list (winners or eliminated) with potential ties
sub print_result_list
{
    my $result_list = shift;
    if (scalar @$result_list) {
        foreach (my $i=0; $i < scalar @$result_list; $i++) {
            my $place = $i+1;
            if (scalar @{$result_list->[$i]} > 1) {
                say "$place  tie: ".join(" ", sort @{$result_list->[$i]});
            } else {
                say "$place: ".$result_list->[$i][0];
            }
        }
    } else {
        say "none";
    }
    return;
}

# get class suffix string
sub suffix
{
    my $class = shift;
    my $class_suffix = $class;
    $class_suffix =~ s/^.*:://x; # remove everything except the last part of the class name
    return $class_suffix;
}

# count tests recursively in blackbox test tree
sub count_tests
{
    my $node = shift;
    my $total = 0;
    if (not ref $node) {
        $total++;
    } elsif (reftype $node eq "HASH") {
        foreach my $key (keys %$node) {
            if (not ref $node) {
                $total++; # redundant but saves a function call
            } else {
                $total += count_tests($node->{$key});
            }
        }
    } elsif (reftype $node eq "ARRAY") {
        foreach my $item (@$node) {
            if (not ref $node) {
                $total++; # redundant but saves a function call
            } else {
                $total += count_tests($item);
            }
        }
    }
    return $total;
}

# count tests for the currently-loaded PrefVote class
sub count_tests_byclass
{
    my ($class, $test_root) = @_;
    my $class_suffix = suffix($class);
    if (exists $test_root->{results} and reftype $test_root->{results} eq "HASH") {
        if (exists $test_root->{results}{$class_suffix} and reftype $test_root->{results}{$class_suffix} eq "HASH") {
            return count_tests($test_root->{results}{$class_suffix});
        }
    } else {
        croak "black box test definition 'results' map not found";
    }
    return 0;
}

# command-line processing
my ($debug, $test_mode, $yaml_format);
GetOptions("debug" => \$debug, "test" => \$test_mode, "yaml" => \$yaml_format);
if (not @ARGV) {
    say STDERR "usage: $0 [--debug] [--test] yaml_file";
    exit 0;
}

# count votes
my $vote_obj = PrefVote::Core::yaml2vote($ARGV[0]);
if ($debug) {
    # set debugging in PrefVote hierarchy
    $vote_obj->debug(1);

    # turn on stack traces for unexpected errors
    ## no critic (Variables::RequireLocalizedPunctuationVars)
    $SIG{ __DIE__ } = sub {confess(@_)};
}
$vote_obj->count();
if ($vote_obj->debug()) {
    local $Data::Dumper::Sortkeys = 1;
    say STDERR "returned vote object is a ".ref($vote_obj);
    say STDERR Dumper($vote_obj);
}

# check for test, YAML or default modes
if ($test_mode) {
    # test mode - run black-box tests
    require Test::More;

    # determine the type of results to process from the vote object


    # count tests from endpoint nodes in extra doc from YAML input
    my $extra = $vote_obj->extra();
    if (ref $extra eq "ARRAY") {
        $extra = $extra->[0];
    }
    my $test_count = count_tests($extra);
    Test::More::plan(tests => $test_count);

    # run tests - everything is in a results map item for readability
    
    if (exists $extra->{results}) {
        # 1st layer within the results test is classes to test against
        # use only tests for the current voting-method class - that's also all we counted in count_tests_byclass()
        my $class_suffix = suffix(ref $vote_obj);
        foreach my $test_class (keys %{$extra->{results}}) {
            if (ref $vote_obj ne "PrefVote::$test_class") {
                my @tests = $vote_obj->blackbox_check($extra->{results}{$test_class});
                foreach my $test (@tests) {
                    # process test case parameters as hashes
                    ## no critic (ControlStructures::ProhibitCascadingIfElse ControlStructures::ProhibitDeepNests)
                    if ($test->{type} eq "is") {
                        is($test->{value}, $test->{expected}, $test->{description}); # feed it to Test::More::is()
                    } elsif ($test->{type} eq "ok") {
                        ok($test->{value}, $test->{description}); # feed it to Test::More::ok()
                    } elsif ($test->{type} eq "pass") {
                        pass($test->{description}); # feed it to Test::More::pass()
                    } elsif ($test->{type} eq "fail") {
                        fail($test->{description}); # feed it to Test::More::fail()
                    }
                }
            }
        }
    }
} elsif ($yaml_format) {
    # output YAML results
    print YAML::XS::Dump($vote_obj->result_yaml());
} else {
    # print result
    my $results = $vote_obj->results();
    say "Winning order";
    print_result_list($results->{winners});
    say "Elimination order";
    print_result_list($results->{eliminated});
}

__END__

# POD documentation

=head1 NAME

vote-count

=head1 USAGE

vote-count vote-data.yaml

=head1 OPTIONS

=head1 EXIT STATUS

=head1 SEE ALSO

=head1 BUGS AND LIMITATIONS

Please report bugs via GitHub at L<https://github.com/ikluft/prefvote/issues>

Patches and enhancements may be submitted via a pull request at L<https://github.com/ikluft/prefvote/pulls>

=cut
