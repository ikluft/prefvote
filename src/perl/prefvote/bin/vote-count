#!/usr/bin/perl
# PODNAME: vote-count
# command line interface to run PrefVote::STV processing YAML input for testing and simple usage example
# derived from Vote::STV by Ian Kluft
# Copyright (c) 1998-2022 by Ian Kluft
# Open Source license: Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0

use Modern::Perl qw(2013); # require 5.16.0 or later
use autodie;
use Carp qw(confess);;
use YAML::XS; # RPM: perl-YAML-LibYAML, DEB: libyaml-libyaml-perl
use PrefVote;
use PrefVote::Core;
use Getopt::Long;
use Data::Dumper;

# print results list (winners or eliminated) with potential ties
sub print_result_list
{
    my $result_list = shift;
    if (scalar @$result_list) {
        foreach (my $i=0; $i < scalar @$result_list; $i++) {
            my $place = $i+1;
            if (scalar @{$result_list->[$i]} > 1) {
                say "$place  tie: ".join(" ", sort @{$result_list->[$i]});
            } else {
                say "$place: ".$result_list->[$i][0];
            }
        }
    } else {
        say "none";
    }
    return;
}

# mainline function for exception-catching
sub main
{
    # command-line processing
    my ($debug, $test_mode, $out_format, $method, %config);
    GetOptions("debug" => \$debug, "test" => \$test_mode, "format|outformat:s" => \$out_format,
        "method:s" => \$method, "config=s" => \%config);
    if (not @ARGV) {
        say STDERR "usage: $0 [--debug] [--test] [--format=output-format] [--method=votingmethod] [--config key=value] "
            ."yaml_file";
        exit 0;
    }

    # transfer command-line config into PrefVote::Config
    # this needs to be done before instantiating $vote_obj so that it has configuration available
    foreach my $key (keys %config) {
        PrefVote->config($key, $config{$key});
    }

    # count votes
    my @opts = ();
    if (defined $method) {
        @opts = ({method => $method});
    }
    my $vote_obj = PrefVote::Core::yaml2vote(@opts, $ARGV[0]);
    if ($debug) {
        # set debugging in PrefVote hierarchy
        $vote_obj->debug(1);
    }

    # run count() for the voting method
    # note: Core is not a voting method but has its own count() which orders results by average ballot position
    $vote_obj->count();
    if ($vote_obj->debug()) {
        $Data::Dumper::Sortkeys = 1;
        $Data::Dumper::Indent = 1;
        say STDERR "returned vote object is a ".ref($vote_obj);
        say STDERR Dumper($vote_obj);
    }

    # check for test, YAML or default modes
    if ($test_mode) {
        # test mode - run black-box tests
        my $testspec = $vote_obj->testspec();
        $vote_obj->debug_print("testspec: ".Dumper($testspec // "undef"));

        # collect and run tests from a voting method (PrefVote:Core subclass)
        if (defined $testspec) {
            # 1st level in testspec is classes (by basename) to test against
            # use only tests for the current voting-method class
            require PrefVote::Core::TestUtil;
            $vote_obj->debug_print("checking tests: ".(ref $vote_obj));
            my @tests = $vote_obj->blackbox_check();
            PrefVote::Core::TestUtil::do_tests(@tests);
        }
    } elsif (defined $out_format) {
        $vote_obj->format_output($out_format);
    } else {
        # print result
        my $results = $vote_obj->results();
        say "Winning order";
        print_result_list($results->{winners});
        say "Elimination order";
        print_result_list($results->{eliminated});
    }
    return 1;
}

# mainline exception-catching wrapper
if (not eval { main() }) {
    my $e = $@;
    if (ref $e and $e->isa("PrefVote::Core::MethodMismatchException")) {
        say STDERR "method skipped: ".$e->{description};
        exit 0;
    }
    if (ref $e and $e->isa("PrefVote::Exception")) {
        say "exception: ".$e->{description};
        #say $e->stack_trace();
        say Dumper($e);
    } else {
        confess $e;
    }
    exit 1;
}

__END__

# POD documentation
=encoding utf8

=head1 NAME

vote-count

=head1 USAGE

  vote-count [--test] [--format=output-type] [--method=voting-method]
    [--config key=name] [--debug] vote-data.yaml

The voting data file provided on the command line is read as YAML containing two or three "YAML documents",
actually sections within the same file.
The first YAML document is the definition of a survey or election including a title and the options or candidates.
The second YAML document contains the survey responses or ballots - these must have been gathered from whichever
source the votes were cast in.
The optional third YAML document is used only for testing (when I<--test> is specified),
and contains data structures from a varified correct
run of counting the supplied votes to compare with the result computed by the software.

L<PrefVote> implements multiple preference voting (ranked choice) algorithms.
By design, all of PrefVote's voting methods are multi-winner methods which may be configured for a single winner.
All of PrefVote's voting methods use Average Choice Rank (ACR), the average ballot position of a choice or candidate,
as a tie-breaker if quantitative vote counts are equal.

=head1 OPTIONS

=over

=item --test

This is a boolean flag which selects black-box testing mode.
The input YAML data must contain a section with expected test results from a previous verified run.

--test is mutually exclusive with --format. If neither is selected it defaults to printing simple results.

=item --format=yaml|rawyaml|text|markdown|html|rawcapture

This option specifies an output format.
"yaml" results in generating YAML output suitable for use in black-box testing.
"rawyaml" is an unfiltered data dump in YAML format.
The other options correspond with a subclass of PrefVote::Core::Output which handles formatting,
either I<text>, I<markdown>, I<html> or I<rawcapture>.
The I<rawcapture> output format is intended as machine-readable - all the machine-readable formats are for testing.
The rest are intended as human-readable output formats.

--format is mutually exlusive with --test. If neither is selected it defaults to printing simple results.

=item --method=core|stv|schulze|rankedpairs

This selects the voting method.

=over 1

=item core

I<Core> isn't really a voting method but represents the common code for all the voting methods supplied by
L<PrefVote::Core>.
It uses the average ballot position of a choice or candidate, such as first, second, third, etc.
That's referred to as Average Choice Rank (ACR) in L<PrefVote::Core>.
Core can be used like a voting method for testing purposes, but should never be used for an actual survey or election.
Since it only uses an average, a hypothetical worst case scenario would be if a candidate received only one vote
but was in first place there, and then averages higher than all the other candidate regardless how many more votes
they receive.

Quantitative information, which is not present in an average, should be used as highest priority first criteria
for deciding the winner of an election.
As a feature of L<PrefVote>, all voting methods use the average choice rank (ACR) for tie-breaking because
it is a qualitative measure of voters' intent on chocies or candidates,
appropriate for cases when quantitative results are equal.

=item stv

I<STV> is the Single Transferable Vote method.
In multiple rounds of vote-counting, any canidates with meet the quota is a winner for that round and
the next available place in the election result.

The quota to win a round is a fraction based on the number of winning seats available.
When a choice wins a round, or more than one wins in a tie, it is considered to consume a fraction of each of the
ballots cast, in the amount necessary to meet the quota. The remaining fractions of each ballot transfer to
the next preference on each ballot.

If no choices win a round, then the choice(s) in last place is/are eliminated.
Their votes transferred to the next available preference on each ballot.

=item schulze

I<Schulze> is the Schulze Method by Marcus Schulze. [...]

=item rankedpairs

I<RankedPairs> is the Ranked Pairs method. [...]

=back

=item --config key=value

=item --debug

=back

=head1 EXIT STATUS

=head1 SEE ALSO

L<PrefVote::Core>

=head1 BUGS AND LIMITATIONS

Please report bugs via GitHub at L<https://github.com/ikluft/prefvote/issues>

Patches and enhancements may be submitted via a pull request at L<https://github.com/ikluft/prefvote/pulls>

=cut
