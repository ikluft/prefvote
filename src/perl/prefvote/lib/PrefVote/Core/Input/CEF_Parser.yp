/*
 * Condorcet Election Format (CEF) grammar
 * CEF_Parser.yp is the CEF grammar used as input for Parse::Yapp to generate CEF_Parser.pm
 * Copyright (c) 2023 by Ian Kluft
 * Open Source license: Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */

%{
    use Readonly;
    Readonly::Array my @CEF_TOKENS => (
        [ EMPTY_RANKING => qr(/EMPTY_RANKING/)x, ],
        [ TAGDELIM      => qr([|][|])x, ],
        [ ','           => qr([,])x, ],
        [ '^'           => qr([\^])x, ],
        [ '*'           => qr([*])x, ],
        [ '='           => qr([=])x, ],
        [ '>'           => qr([>])x, ],
        [ INT           => qr(\d+)x, ],
        [ WORD          => qr(\w+)x, ],
    );
%}

/* token declarations */
%token WORD      /* word characters including embedded whitespace */
%token INT       /* integer */
%token TAGDELIM  /* || delimits tags from ranking */
%token ','       /* comma delimits multiple tags */
%token '*'       /* quantifier op */
%token '^'       /* weight op */
%token '>'       /* preference op */
%token '='       /* equality op */
%token EMPTY_RANKING  /* empty ballot ranking denoted by string /EMPTY_RANKING/ */

/* grammar */
%%

line:
    tags TAGDELIM ranking       { return [ $_[2], @{$_[2]} ]; }
|   ranking                     { return $_[1]; }
;

tags:
    tags ',' tag                { return [ @{$_[1]}, @{$_[3]} ]; }
|   tag                         { return [ $_[1] ]; }
;

tag:
    words                       { return $_[1]; }
;

ranking:
    choice_list multipliers     { return [ (defined $_[2]) ? ($_[2]) : (), @{$_[1]} ]; }
|   EMPTY_RANKING               { return []; }
;

choice_list:
    choice_list '>' equal_list  { return [ @{$_[1]}, $_[3] ]; }
|   equal_list                  { return [ $_[1] ]; }
;

equal_list:
    equal_list '=' candidate    { return [ @{$_[1]}, $_[3] ]; }
|   candidate                   { return [ $_[1] ]; }
;

candidate:
    words                       { return $_[1]; }
;

multipliers:
|   quantifier weight           { return { %{$_[1]}, %{$_[2]} }; }
|   weight quantifier           { return { %{$_[1]}, %{$_[2]} }; }
|   quantifier                  { return $_[1]; }
|   weight                      { return $_[1]; }
;

quantifier:
    '*' INT                     { return { quantifier => $_[2]}; }
;

weight:
    '^' INT                     { return { weight => $_[2]}; }
;

words:
    words word                  { return $_[1] . " " . $_[2]; }
|   word                        { return "" . $_[1]; }
;

word:
    WORD                        { return "" . $_[1]; }
|   INT                         { return 0 + $_[1]; }
;

%%

sub _Error
{
    my( $parser ) = @_;
    exists $parser->YYData->{ERRMSG}
        and do {
            say $parser->YYData->{ERRMSG};
            delete $parser->YYData->{ERRMSG};
            return;
        };
    say "Syntax error at position " . $parser->{USER}{CHARNO}
        . ", found " . $parser->YYCurtok . " '" . $parser->YYCurval . "'"
        . ", expected " . join( ' ', $parser->YYExpect );
    return;
}

sub _Lexer
{
    my ($parser) = shift;

    $parser->YYData->{INPUT}
        or return ( '', undef );

    if( $parser->YYData->{INPUT} =~ s/^ ( \s+ )//x ) {
        $parser->{USER}{CHARNO} += length $1;
    }

    for ( $parser->YYData->{INPUT} ) {
        foreach my $token_pair ( @CEF_TOKENS ) {
            my ( $token_name, $token_regex ) = @$token_pair;
            if (s/ ^ ( $token_regex ) //x) {
                $parser->{USER}{CHARNO} += length $1;
                return ( $token_name, $1 );
            }
        }
    }
    return;
}

sub parse
{
    my ($self, $input_str) = @_;
    $self->YYData->{INPUT} = $input_str;
    $self->{USER}{CHARNO}  = 0;
    my $result = $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
    return $result;
}
