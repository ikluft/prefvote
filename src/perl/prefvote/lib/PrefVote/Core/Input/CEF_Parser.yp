/*
 * Condorcet Election Format (CEF) grammar
 */

%{
    use Readonly;
    Readonly::Hash my %CEF_TOKENS => (
        EMPTY_RANKING => qr(/EMPTY_RANKING/)x,
        TAGDELIM => qr([|][|])x,
        ',' => qr([,])x,
        '^' => qr([\^])x,
        '*' => qr([*])x,
        '=' => qr([=])x,
        '>' => qr([>])x,
        INT => qr(\d+)x,
        WORD => qr(\w+)x,
    );
%}

/* token declarations */
%token WORD      /* word characters including embedded whitespace */
%token INT       /* integer */
%token TAGDELIM  /* || delimits tags from ranking */
%token ','       /* comma delimits multiple tags */
%token '*'       /* quantifier op */
%token '^'       /* weight op */
%token '='       /* equality op */
%token '>'       /* preference op */
%token EMPTY_RANKING  /* empty ballot ranking denoted by string /EMPTY_RANKING/ */

/* grammar */
%%

line:
    tags TAGDELIM ranking       { return [ $_[2], @{$_[2]} ]; }
|   ranking                     { return $_[1]; }
;

tags:
    tags ',' tag                { return [ @{$_[1]}, @{$_[3]} ]; }
|   tag                         { return [ $_[1] ]; }
;

tag:
    words                       { return $_[1]; }
;

ranking:
    choice_list multipliers     { return [ $_[2], @{$_[1]} ]; }
|   EMPTY_RANKING               { return []; }
;

choice_list:
    choice_list '>' equal_list  { return [ @{$_[1]}, @{$_[3]} ]; }
|   equal_list                  { return [ $_[1] ]; }
;

equal_list:
    equal_list '=' candidate    { return [ @{$_[1]}, @{$_[3]} ]; }
|   candidate                   { return [ $_[1] ]; }
;

candidate:
    words                       { return $_[1]; }
;

multipliers:
|   quantifier weight           { return { %{$_[1]}, %{$_[2]} }; }
|   weight quantifier           { return { %{$_[1]}, %{$_[2]} }; }
|   quantifier                  { return $_[1]; }
|   weight                      { return $_[1]; }
;

quantifier:
    '^' INT                     { return { quantifier => $_[1]}; }
;

weight:
    '*' INT                     { return { weight => $_[1]}; }
;

words:
    words word                  { return $_[1] . " " . $_[2]; }
|   word                        { return "" . $_[1]; }
;

word:
    WORD                        { return "" . $_[1]; }
|   INT                         { return 0 + $_[1]; }
;

%%

sub _Error {
        exists $_[0]->YYData->{ERRMSG}
    and do {
        print $_[0]->YYData->{ERRMSG};
        delete $_[0]->YYData->{ERRMSG};
        return;
    };
    print "Syntax error.\n";
    return;
}

sub _Lexer {
    my($parser)=shift;

    $parser->YYData->{INPUT}
        or  $parser->YYData->{INPUT} = <STDIN>
        or  return('',undef);

    $parser->YYData->{INPUT}=~s/^ \s//x;

    for ($parser->YYData->{INPUT}) {
        foreach my $key (keys %CEF_TOKENS) {
            if ( s/ ^ ( $CEF_TOKENS{$key} ) //x ) {
                return($key, $1);
            }
        }
    }
    return;
}

sub parse {
    my($self)=shift;
    my $result = $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
    return $result;
}
